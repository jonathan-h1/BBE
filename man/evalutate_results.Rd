% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evaluate_results.R
\name{evalutate_results}
\alias{evalutate_results}
\title{Evaluate the performance of an algorithm in a basin separated manner.
Internally the basins are determined with the efficient points
and the gradients calculated by \link{'moPlot'} for the rasterized decision space.
See the paper for more details. In the following the number of dimensions in
the decision space will be denoted as dec.nDim and the number of dimensions in
the objective space will be denoted as obj.nDim.}
\usage{
evalutate_results(
  results,
  fn,
  ...,
  eval_fn = ecr::computeHV,
  grid_size = 300L,
  basins = 1:3,
  join_fronts = FALSE,
  efficient_sets = NULL,
  dec_space_labels = NULL
)
}
\arguments{
\item{results}{[\code{tibble}] \cr
A tibble with the results of an algorithm run. It should be
organized as follows: The first column should contain the function calls needed
to retrieve the solutions captured in the remaining columns. The second column
until the 1 + dec.nDim column should contain the coordinates of the solutions
in the decision space. Finally, the remaining columns should contain the
coordinates in the objective space. Note that the point will be grouped by
the function calls needed to retrieve them. Thus, make sure that points that
should be evaluated together have the same value in the first column.}

\item{fn}{[\code{function}] \cr
The multi-objective function under consideration.
It should be a \link{'smoof'}-function. The number of objectives and the upper and
lower bounds are inferred from the function.}

\item{...}{[\code{any}] \cr
Further arguments that should be passed to \link{'eval_fn'}.
In the default case \code{ref.point} should be passed here
for the calculation of the hypervolume.}

\item{eval_fn}{[\code{function}] \cr
The function that is used to evaluate the solutions in a basin.
It should accept the points in a column wise dataframe. The default is
\link{'computeHV'}.}

\item{grid_size}{[\code{integer(1)}] \cr
The granuality of the raster per dimension. The default is 300.}

\item{basins}{[\code{integer}] \cr
A vector of integers identifying the basins that should be
considered during the evaluation. The default is to consider the first three
basins.}

\item{join_fronts}{[\code{logical(1)}] \cr
This should be \code{TRUE} if the efficient sets should be joined when
they are part of the same domination front. Default is \code{FALSE}.}

\item{efficient_sets}{[\code{list} | \code{NULL}] \cr
If the efficient points returned by \link{'moPLOT'} are not accurate or enought and
more precice locations are available they or a custom merging of sets is wanted
this can be supplyed here. Expected is a list of vectors containing the indices
of the gridcells that should be regarded an efficient point.
An element of the List is treated as one efficient set.
If \code{NULL} the efficient points returned by \link{'moPLOT'} are merged
to efficient sets and those are then ordered by the number of points
in a domination layer. Default is \code{NULL}.}

\item{dec_space_labels}{[\code{integer} | \code{NULL}] \cr
If a custom labeling of the grid in the decision space is wanted
the labels can be supplied here. The vector should contain the wanted label
at the position of the index of a cell in the grid. If \code{NULL} the labels
are computed from the points in the efficient sets.}
}
\value{
[\code{list}] \cr
A \code{design} list from \link{'moPLOT'}. Additionally attached are
the efficient sets (\code{efficientSets}), the labels for the decision space
(\code{decSpaceLabels}) and a tibble (\code{basin_separated_eval})
with the basin separated results.
}
\description{
Evaluate the performance of an algorithm in a basin separated manner.
Internally the basins are determined with the efficient points
and the gradients calculated by \link{'moPlot'} for the rasterized decision space.
See the paper for more details. In the following the number of dimensions in
the decision space will be denoted as dec.nDim and the number of dimensions in
the objective space will be denoted as obj.nDim.
}
\examples{
# NOT RUN {
fn <- smoof::makeDTLZ1function(2,2)
# dummy tibble
tb <- tibble::tibble(fc = 5, x1 = 0.5, x2 = 0.5, y1 = 0.25, y2 = 0.25)
evalutate_results(tb, fn, ref.point = smoof::getRefPoint(fn))
# }
}
