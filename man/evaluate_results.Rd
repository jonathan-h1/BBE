% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evaluate_results.R
\name{evaluate_results}
\alias{evaluate_results}
\title{Apply BBE}
\usage{
evaluate_results(
  results,
  fn,
  ...,
  eval_fn = ecr::computeHV,
  grid_size = 300L,
  basins = 1:3,
  join_fronts = FALSE,
  keep_points = FALSE,
  efficient_sets = NULL,
  dec_space_labels = NULL,
  design = NULL
)
}
\arguments{
\item{results}{[\code{tibble}] \cr
A tibble with the results of an algorithm run. It should be organized
as follows: The first column should contain the ascending number of
function calls needed to retrieve the solutions captured in the remaining
columns. The second column until the 1 + dec.nDim column should contain the
coordinates of the solutions in the decision space
(named $x_1$ to $x_{1 + dec.nDim}). Finally, the remaining columns
should contain the coordinates in the objective space. Note that
the point will be grouped by the function calls needed to retrieve them.
Thus, make sure that points that should be evaluated together have the same
value in the first column.}

\item{fn}{[\code{function}] \cr
The multi-objective function under consideration.
It should be a \link{'smoof'}-function. The number of objectives, the upper and
lower bounds are inferred from the function.}

\item{...}{[\code{any}] \cr
Further arguments that should be passed to \link{'eval_fn'}.
In the default case \code{ref.point} should be passed here
for the calculation of the hypervolume.}

\item{eval_fn}{[\code{function}] \cr
The function that is used to evaluate the solutions in a basin.
It should accept the points in a column wise dataframe. The default is
\link['ecr:computeHV']{'ecr::computeHV'}.}

\item{grid_size}{[\code{integer(1)}] \cr
The granuality of the raster per dimension. The default is 300.}

\item{basins}{[\code{integer}] \cr
A vector of integers identifying the basins that should be
considered during the evaluation. The default is to consider the first three
basins.}

\item{join_fronts}{[\code{logical(1)}] \cr
This should be \code{TRUE} if the efficient sets should be joined when
they are part of the same domination front. Default is \code{FALSE}.}

\item{keep_points}{[\code{logical(1)}] \cr
Should all prior found points be considered as well when considering the
current set of points for a specific number of function calls?
Default is \code{FALSE}.}

\item{efficient_sets}{[\code{list} | \code{NULL}] \cr
If the efficient points returned by \link{'moPLOT'} are not accurate, or enought
and more precice locations are available, or a custom merging of sets is
wanted this can be supplyed here. Expected is a list of vectors containing
the indices of the gridcells that should be regarded an efficient point.
An element of the List is treated as one efficient set.
If \code{NULL} the efficient points returned by \link{'moPLOT'} are merged
to efficient sets and those are then ordered by the number of points
in a domination layer. Default is \code{NULL}.}

\item{dec_space_labels}{[\code{integer} | \code{NULL}] \cr
If a custom labeling of the grid in the decision space is wanted
the labels can be supplied here. The vector should contain the wanted label
at the position of the index of a cell in the grid. If \code{NULL} the
labels are computed from the points in the efficient sets.}

\item{design}{[\code{list} | \code{NULL}] \cr
If a design with \code{efficient_sets} and \code{dec_space_labels} was
already created by either this function or \link{'get_decision_space_labels'} it
can be reused with this parameter.}
}
\value{
[\code{list}] \cr
A \code{design} list from \link{'moPLOT'}. Additionally attached are
the efficient sets (\code{efficientSets}), the labels for the decision space
(\code{decSpaceLabels}) and a tibble (\code{basin_separated_eval})
with the basin separated results.
}
\description{
Evaluate the performance of an algorithm in a basin-based manner.
Internally the basins are determined with the efficient points
and the gradients calculated by \link{'moPlot'} for the rasterized decision space.
See the paper for more details. In the following the number of dimensions in
the decision space will be denoted as dec.nDim and the number of dimensions
in the objective space will be denoted as obj.nDim.
}
\examples{
# NOT RUN {
fn <- smoof::makeDTLZ1Function(2,2)
# tibble with an examplary NSGAII run on DTLZ1
tb <- nsga2_dtlz1_run[, c('fun_calls', 'x1', 'x2', 'y1', 'y2')]
evaluate_results(tb, fn, ref.point = smoof::getRefPoint(fn))
# }
}
